From 8246deb2537f74b94c33ba9d740104597b22e155 Mon Sep 17 00:00:00 2001
From: "Reynaldo H. Verdejo Pinochet" <reynaldo@collabora.com>
Date: Tue, 7 May 2013 23:00:55 -0400
Subject: [PATCH 3/4] Port get_host_ip() to Android/Bionic [pass 2]

Add multiple device enumeration/config getter code
---
 libgssdp/gssdp-client.c |   85 ++++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 73 insertions(+), 12 deletions(-)

diff --git a/libgssdp/gssdp-client.c b/libgssdp/gssdp-client.c
index e8fb77b..26fbb07 100644
--- a/libgssdp/gssdp-client.c
+++ b/libgssdp/gssdp-client.c
@@ -1248,16 +1248,19 @@ get_host_ip (GSSDPNetworkDevice *device)
 
         return TRUE;
 #elif __BIONIC__
-        struct ifreq *iface;
-        int sock;
-
+        struct  ifreq *iface = NULL;
+        struct  ifconf ifconfigs;
+        struct  sockaddr_in *address;
+        int     if_limit, sock, i;
+        gboolean got_all;
 
         if ((sock = socket (AF_INET, SOCK_STREAM, 0)) < 0)
-                return FALSE;
+                goto fail;
+
+        iface = g_malloc0 (sizeof (struct ifreq));
 
         if (device->iface_name != NULL) {
                 /* We have an actual interface request */
-                iface = calloc (1, sizeof (struct ifreq));
                 strncpy (iface->ifr_name, device->iface_name, IFNAMSIZ);
 
                 if (ioctl (sock, SIOCGIFADDR, iface) == -1)
@@ -1268,27 +1271,85 @@ get_host_ip (GSSDPNetworkDevice *device)
 
                 /* FIXME: is IPv4 all we need?
                  * Should also check buffer size against INET_ADDRSTRLEN */
+
+                device->host_ip = g_malloc0 (INET_ADDRSTRLEN);
                 if (inet_ntop (AF_INET, &device->mask.sin_addr, device->host_ip,
                         INET_ADDRSTRLEN) == NULL) {
+                        g_free (device->host_ip);
                         goto cleanup_and_fail;
                 }
 
-                goto cleanup;
+                goto success;
+
+        }
 
-        } else {
         /* No interface name was passed on as query. Need
          * to figure out address of the first active/configured
          * device and pass that over
          */
 
+
+        /* Fill ifc_buf with the available interfaces */
+
+        got_all = FALSE;
+        if_limit = 5; /* We probe for 5 ifaces for starters */
+
+        do {
+                iface = g_realloc (iface, if_limit * sizeof (struct ifreq));
+                ifconfigs.ifc_len = if_limit;
+                ifconfigs.ifc_buf = (char *) iface;
+
+                /* FIXME: Make sure IPv4 interfaces are all what's
+                 * needed cause you get nothing but AF_INET ones from
+                 * this ioctl
+                 */
+                if (ioctl (sock, SIOCGIFCONF, &ifconfigs) == -1)
+                        goto cleanup_and_fail;
+
+                /* Check for overflow (not an error). Resize and re-ioctl
+                 * if this is the case to get the full list */
+                if (ifconfigs.ifc_len < if_limit)
+                        got_all = TRUE;
+                else
+                        if_limit += 5; /* +5 should be enough for everybody ;) */
+
+        } while (!got_all);
+
+        /* Got the list. Find and set (on *device)
+         * data for the first configured device and
+         * return */
+
+        for (i = 0; i < ifconfigs.ifc_len; i++) {
+
+                address = (struct sockaddr_in *) &(iface[i].ifr_addr);
+
+                if (address->sin_addr.s_addr) {
+
+                        memcpy (&device->mask, address,
+                                sizeof (struct sockaddr_in));
+                        device->iface_name = g_strdup (iface[i].ifr_name);
+
+                        /* Again, only IPv4 */
+                        device->host_ip = g_malloc0 (INET_ADDRSTRLEN);
+                        if (inet_ntop (AF_INET, &device->mask.sin_addr,
+                                device->host_ip, INET_ADDRSTRLEN) == NULL) {
+                                g_free (device->iface_name);
+                                g_free (device->host_ip);
+                                goto cleanup_and_fail;
+                        }
+
+                        goto success;
+
+                }
         }
 
-cleanup:
-        free (iface);
-        return TRUE;
-cleanup_and_fail: /* Maybe print meaningfull message or smth? */
-        free (iface);
+cleanup_and_fail:
+        g_free (iface);
+fail:
         return FALSE;
+success:
+        g_free (iface);
+        return TRUE;
 #else
         struct ifaddrs *ifa_list, *ifa;
         GList *up_ifaces, *ifaceptr;
-- 
1.7.10.4

