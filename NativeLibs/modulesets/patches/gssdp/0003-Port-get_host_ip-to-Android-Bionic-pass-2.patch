From f8eaad102474cf0a824c689e950d9d5040600996 Mon Sep 17 00:00:00 2001
From: "Reynaldo H. Verdejo Pinochet" <reynaldo@collabora.com>
Date: Tue, 7 May 2013 23:00:55 -0400
Subject: [PATCH 3/3] Port get_host_ip() to Android/Bionic [pass 2]

Add multiple device enumeration/config getter code
---
 libgssdp/gssdp-client.c |   69 +++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 61 insertions(+), 8 deletions(-)

diff --git a/libgssdp/gssdp-client.c b/libgssdp/gssdp-client.c
index e8fb77b..f91cadf 100644
--- a/libgssdp/gssdp-client.c
+++ b/libgssdp/gssdp-client.c
@@ -1248,12 +1248,14 @@ get_host_ip (GSSDPNetworkDevice *device)
 
         return TRUE;
 #elif __BIONIC__
-        struct ifreq *iface;
-        int sock;
-
+        struct  ifreq *iface = NULL;
+        struct  ifconf ifconfigs;
+        struct  sockaddr_in *address;
+        int     if_limit, sock, i;
+        gboolean got_all;
 
         if ((sock = socket (AF_INET, SOCK_STREAM, 0)) < 0)
-                return FALSE;
+                goto fail;
 
         if (device->iface_name != NULL) {
                 /* We have an actual interface request */
@@ -1275,20 +1277,71 @@ get_host_ip (GSSDPNetworkDevice *device)
 
                 goto cleanup;
 
-        } else {
+        }
+
         /* No interface name was passed on as query. Need
          * to figure out address of the first active/configured
          * device and pass that over
          */
 
+
+        /* Fill ifc_buf with the available interfaces */
+
+        got_all = FALSE;
+        if_limit = 5; /* We probe for 5 ifaces for starters */
+
+        do {
+                realloc (iface, if_limit * sizeof (struct ifreq));
+                ifconfigs.ifc_len = if_limit;
+                ifconfigs.ifc_buf = (char *) iface;
+
+                /* FIXME: Make sure IPv4 interfaces are all what's
+                 * needed cause you get nothing but AF_INET ones from
+                 * this ioctl
+                 */
+                if (ioctl (sock, SIOCGIFCONF, &ifconfigs) == -1)
+                        goto cleanup_and_fail;
+
+                /* Check for overflow (not an error). Resize and re-ioctl
+                 * if this is the case to get the full list */
+                if (ifconfigs.ifc_len < if_limit)
+                        got_all = TRUE;
+                else
+                        if_limit += 5; /* +5 should be enough for everybody ;) */
+
+        } while (!got_all);
+
+        /* Got the list. Find and set (on *device)
+         * data for the first configured device and
+         * return */
+
+        for (i = 0; i < ifconfigs.ifc_len; i++) {
+
+                address = &(iface[i].ifr_addr);
+
+                if (address->sin_addr.s_addr) {
+
+                        memcpy (&device->mask, address,
+                                sizeof (struct sockaddr_in));
+
+                        /* Again, only IPv4 */
+                        if (inet_ntop (AF_INET, &device->mask.sin_addr,
+                                device->host_ip, INET_ADDRSTRLEN) == NULL) {
+                                goto cleanup_and_fail;
+                        }
+
+                        goto cleanup;
+
+                }
         }
 
+cleanup_and_fail:
+        free (iface);
+fail: /* Maybe print meaningfull message or smth? */
+        return FALSE;
 cleanup:
         free (iface);
         return TRUE;
-cleanup_and_fail: /* Maybe print meaningfull message or smth? */
-        free (iface);
-        return FALSE;
 #else
         struct ifaddrs *ifa_list, *ifa;
         GList *up_ifaces, *ifaceptr;
-- 
1.7.10.4

